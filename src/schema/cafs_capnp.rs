// Generated by the capnpc-rust plugin to the Cap'n Proto schema compiler.
// DO NOT EDIT.
// source: cafs.capnp


pub mod reference {
  #![allow(unused_imports)]
  use capnp::capability::{FromClientHook, FromTypelessPipeline};
  use capnp::{text, data, Result};
  use capnp::private::layout;
  use capnp::traits::{FromStructBuilder, FromStructReader};
  use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};

  pub use self::Which::{File,Directory,Volume};

  pub struct Owned;
  impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
  impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

  #[derive(Clone, Copy)]
  pub struct Reader<'a> { reader : layout::StructReader<'a> }

  impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>
  {
    #[inline]
    fn type_id() -> u64 { _private::TYPE_ID }
  }
  impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>
  {
    fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
      Reader { reader : reader,  }
    }
  }

  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>
  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a,>> {
      ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
    }
  }

  impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>
  {
    fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
      self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
    }
  }

  impl <'a,> Reader<'a,>
  {
    pub fn borrow<'b>(&'b self) -> Reader<'b,> {
      Reader { .. *self }
    }

    pub fn total_size(&self) -> Result<::capnp::MessageSize> {
      self.reader.total_size()
    }
    pub fn has_file(&self) -> bool {
      if self.reader.get_data_field::<u16>(0) != 0 { return false; }
      !self.reader.get_pointer_field(0).is_null()
    }
    pub fn has_directory(&self) -> bool {
      if self.reader.get_data_field::<u16>(0) != 1 { return false; }
      !self.reader.get_pointer_field(0).is_null()
    }
    pub fn has_volume(&self) -> bool {
      if self.reader.get_data_field::<u16>(0) != 2 { return false; }
      !self.reader.get_pointer_field(0).is_null()
    }
    #[inline]
    pub fn which(self) -> ::std::result::Result<WhichReader<'a,>, ::capnp::NotInSchema> {
      match self.reader.get_data_field::<u16>(0) {
        0 => {
          return ::std::result::Result::Ok(File(
            ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))
          ));
        }
        1 => {
          return ::std::result::Result::Ok(Directory(
            ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))
          ));
        }
        2 => {
          return ::std::result::Result::Ok(Volume(
            ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))
          ));
        }
        x => return ::std::result::Result::Err(::capnp::NotInSchema(x))
      }
    }
  }

  pub struct Builder<'a> { builder : ::capnp::private::layout::StructBuilder<'a> }
  impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>
  {
    #[inline]
    fn struct_size() -> layout::StructSize { _private::STRUCT_SIZE }
  }
  impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>
   {
    #[inline]
    fn type_id() -> u64 { _private::TYPE_ID }
  }
  impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>
   {
    fn new(builder : ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
      Builder { builder : builder,  }
    }
  }

  impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>
   {
    fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
      self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
    }
  }

  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>
   {
    fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size : u32) -> Builder<'a,> {
      ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a,>> {
      ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
    }
  }

  impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>
   {
    fn set_pointer_builder<'b>(pointer : ::capnp::private::layout::PointerBuilder<'b>, value : Reader<'a,>) -> Result<()> { pointer.set_struct(&value.reader) }
  }

  impl <'a,> Builder<'a,>
   {
    pub fn as_reader(self) -> Reader<'a,> {
      ::capnp::traits::FromStructReader::new(self.builder.as_reader())
    }
    pub fn borrow<'b>(&'b mut self) -> Builder<'b,> {
      Builder { .. *self }
    }
    pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b,> {
      ::capnp::traits::FromStructReader::new(self.builder.as_reader())
    }

    pub fn total_size(&self) -> Result<::capnp::MessageSize> {
      self.builder.as_reader().total_size()
    }
    #[inline]
    pub fn set_file<'b>(&mut self, value : ::cafs_capnp::reference::data_ref::Reader<'b>) -> Result<()> {
      self.builder.set_data_field::<u16>(0, 0);
      ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
    }
    #[inline]
    pub fn init_file(self, ) -> ::cafs_capnp::reference::data_ref::Builder<'a> {
      self.builder.set_data_field::<u16>(0, 0);
      ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
    }
    pub fn has_file(&self) -> bool {
      if self.builder.get_data_field::<u16>(0) != 0 { return false; }
      !self.builder.get_pointer_field(0).is_null()
    }
    #[inline]
    pub fn set_directory<'b>(&mut self, value : ::cafs_capnp::reference::data_ref::Reader<'b>) -> Result<()> {
      self.builder.set_data_field::<u16>(0, 1);
      ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
    }
    #[inline]
    pub fn init_directory(self, ) -> ::cafs_capnp::reference::data_ref::Builder<'a> {
      self.builder.set_data_field::<u16>(0, 1);
      ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
    }
    pub fn has_directory(&self) -> bool {
      if self.builder.get_data_field::<u16>(0) != 1 { return false; }
      !self.builder.get_pointer_field(0).is_null()
    }
    #[inline]
    pub fn set_volume<'b>(&mut self, value : ::cafs_capnp::reference::volume_ref::Reader<'b>) -> Result<()> {
      self.builder.set_data_field::<u16>(0, 2);
      ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
    }
    #[inline]
    pub fn init_volume(self, ) -> ::cafs_capnp::reference::volume_ref::Builder<'a> {
      self.builder.set_data_field::<u16>(0, 2);
      ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
    }
    pub fn has_volume(&self) -> bool {
      if self.builder.get_data_field::<u16>(0) != 2 { return false; }
      !self.builder.get_pointer_field(0).is_null()
    }
    #[inline]
    pub fn which(self) -> ::std::result::Result<WhichBuilder<'a,>, ::capnp::NotInSchema> {
      match self.builder.get_data_field::<u16>(0) {
        0 => {
          return ::std::result::Result::Ok(File(
            ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))
          ));
        }
        1 => {
          return ::std::result::Result::Ok(Directory(
            ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))
          ));
        }
        2 => {
          return ::std::result::Result::Ok(Volume(
            ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))
          ));
        }
        x => return ::std::result::Result::Err(::capnp::NotInSchema(x))
      }
    }
  }

  pub struct Pipeline { _typeless : ::capnp::any_pointer::Pipeline }
  impl FromTypelessPipeline for Pipeline {
    fn new(typeless : ::capnp::any_pointer::Pipeline) -> Pipeline {
      Pipeline { _typeless : typeless,  }
    }
  }
  impl Pipeline {
  }
  mod _private {
    use capnp::private::layout;
    pub const STRUCT_SIZE : layout::StructSize = layout::StructSize { data : 1, pointers : 1 };
    pub const TYPE_ID: u64 = 0xc4d61977a414ab94;
  }
  pub enum Which<A0,A1,A2> {
    File(A0),
    Directory(A1),
    Volume(A2),
  }
  pub type WhichReader<'a,> = Which<Result<::cafs_capnp::reference::data_ref::Reader<'a>>,Result<::cafs_capnp::reference::data_ref::Reader<'a>>,Result<::cafs_capnp::reference::volume_ref::Reader<'a>>>;
  pub type WhichBuilder<'a,> = Which<Result<::cafs_capnp::reference::data_ref::Builder<'a>>,Result<::cafs_capnp::reference::data_ref::Builder<'a>>,Result<::cafs_capnp::reference::volume_ref::Builder<'a>>>;

  pub mod raw_block_ref {
    #![allow(unused_imports)]
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::{text, data, Result};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};

    pub struct Owned;
    impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> { reader : layout::StructReader<'a> }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>
    {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>
    {
      fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
        Reader { reader : reader,  }
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>
    {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>
    {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>
    {
      pub fn borrow<'b>(&'b self) -> Reader<'b,> {
        Reader { .. *self }
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_sha256(self) -> Result<data::Reader<'a>> {
        self.reader.get_pointer_field(0).get_data(::std::ptr::null(), 0)
      }
      pub fn has_sha256(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder : ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>
    {
      #[inline]
      fn struct_size() -> layout::StructSize { _private::STRUCT_SIZE }
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>
     {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>
     {
      fn new(builder : ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
        Builder { builder : builder,  }
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>
     {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>
     {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size : u32) -> Builder<'a,> {
        ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>
     {
      fn set_pointer_builder<'b>(pointer : ::capnp::private::layout::PointerBuilder<'b>, value : Reader<'a,>) -> Result<()> { pointer.set_struct(&value.reader) }
    }

    impl <'a,> Builder<'a,>
     {
      pub fn as_reader(self) -> Reader<'a,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }
      pub fn borrow<'b>(&'b mut self) -> Builder<'b,> {
        Builder { .. *self }
      }
      pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_sha256(self) -> Result<data::Builder<'a>> {
        self.builder.get_pointer_field(0).get_data(::std::ptr::null(), 0)
      }
      #[inline]
      pub fn set_sha256(&mut self, value : data::Reader)  {
        self.builder.get_pointer_field(0).set_data(value);
      }
      #[inline]
      pub fn init_sha256(self, size : u32) -> data::Builder<'a> {
        self.builder.get_pointer_field(0).init_data(size)
      }
      pub fn has_sha256(&self) -> bool {
        !self.builder.get_pointer_field(0).is_null()
      }
    }

    pub struct Pipeline { _typeless : ::capnp::any_pointer::Pipeline }
    impl FromTypelessPipeline for Pipeline {
      fn new(typeless : ::capnp::any_pointer::Pipeline) -> Pipeline {
        Pipeline { _typeless : typeless,  }
      }
    }
    impl Pipeline {
    }
    mod _private {
      use capnp::private::layout;
      pub const STRUCT_SIZE : layout::StructSize = layout::StructSize { data : 0, pointers : 1 };
      pub const TYPE_ID: u64 = 0xc2ac82c1c6c9adc3;
    }
  }

  pub mod block_ref {
    #![allow(unused_imports)]
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::{text, data, Result};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};

    pub struct Owned;
    impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> { reader : layout::StructReader<'a> }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>
    {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>
    {
      fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
        Reader { reader : reader,  }
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>
    {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>
    {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>
    {
      pub fn borrow<'b>(&'b self) -> Reader<'b,> {
        Reader { .. *self }
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_rawblock(self) -> Result<::cafs_capnp::reference::raw_block_ref::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))
      }
      pub fn has_rawblock(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_size(self) -> u64 {
        self.reader.get_data_field::<u64>(0)
      }
      #[inline]
      pub fn get_enc(self) -> ::cafs_capnp::reference::block_ref::enc::Reader<'a> {
        ::capnp::traits::FromStructReader::new(self.reader)
      }
    }

    pub struct Builder<'a> { builder : ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>
    {
      #[inline]
      fn struct_size() -> layout::StructSize { _private::STRUCT_SIZE }
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>
     {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>
     {
      fn new(builder : ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
        Builder { builder : builder,  }
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>
     {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>
     {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size : u32) -> Builder<'a,> {
        ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>
     {
      fn set_pointer_builder<'b>(pointer : ::capnp::private::layout::PointerBuilder<'b>, value : Reader<'a,>) -> Result<()> { pointer.set_struct(&value.reader) }
    }

    impl <'a,> Builder<'a,>
     {
      pub fn as_reader(self) -> Reader<'a,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }
      pub fn borrow<'b>(&'b mut self) -> Builder<'b,> {
        Builder { .. *self }
      }
      pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_rawblock(self) -> Result<::cafs_capnp::reference::raw_block_ref::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))
      }
      #[inline]
      pub fn set_rawblock<'b>(&mut self, value : ::cafs_capnp::reference::raw_block_ref::Reader<'b>) -> Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
      }
      #[inline]
      pub fn init_rawblock(self, ) -> ::cafs_capnp::reference::raw_block_ref::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      pub fn has_rawblock(&self) -> bool {
        !self.builder.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_size(self) -> u64 {
        self.builder.get_data_field::<u64>(0)
      }
      #[inline]
      pub fn set_size(&mut self, value : u64)  {
        self.builder.set_data_field::<u64>(0, value);
      }
      #[inline]
      pub fn get_enc(self) -> ::cafs_capnp::reference::block_ref::enc::Builder<'a> {
        ::capnp::traits::FromStructBuilder::new(self.builder)
      }
      #[inline]
      pub fn init_enc(self, ) -> ::cafs_capnp::reference::block_ref::enc::Builder<'a> {
        self.builder.set_data_field::<u16>(4, 0);
        self.builder.get_pointer_field(1).clear();
        ::capnp::traits::FromStructBuilder::new(self.builder)
      }
    }

    pub struct Pipeline { _typeless : ::capnp::any_pointer::Pipeline }
    impl FromTypelessPipeline for Pipeline {
      fn new(typeless : ::capnp::any_pointer::Pipeline) -> Pipeline {
        Pipeline { _typeless : typeless,  }
      }
    }
    impl Pipeline {
      pub fn get_rawblock(&self) -> ::cafs_capnp::reference::raw_block_ref::Pipeline<> {
        FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
      pub fn get_enc(&self) -> ::cafs_capnp::reference::block_ref::enc::Pipeline {
        FromTypelessPipeline::new(self._typeless.noop())
      }
    }
    mod _private {
      use capnp::private::layout;
      pub const STRUCT_SIZE : layout::StructSize = layout::StructSize { data : 2, pointers : 2 };
      pub const TYPE_ID: u64 = 0xdfbf49a6dffb365b;
    }

    pub mod enc {
      #![allow(unused_imports)]
      use capnp::capability::{FromClientHook, FromTypelessPipeline};
      use capnp::{text, data, Result};
      use capnp::private::layout;
      use capnp::traits::{FromStructBuilder, FromStructReader};
      use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};

      pub use self::Which::{None,Aes};

      pub struct Owned;
      impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
      impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

      #[derive(Clone, Copy)]
      pub struct Reader<'a> { reader : layout::StructReader<'a> }

      impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>
      {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>
      {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
          Reader { reader : reader,  }
        }
      }

      impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>
      {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>
      {
        fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
          self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
        }
      }

      impl <'a,> Reader<'a,>
      {
        pub fn borrow<'b>(&'b self) -> Reader<'b,> {
          Reader { .. *self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
          self.reader.total_size()
        }
        pub fn has_aes(&self) -> bool {
          if self.reader.get_data_field::<u16>(4) != 1 { return false; }
          !self.reader.get_pointer_field(1).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichReader<'a,>, ::capnp::NotInSchema> {
          match self.reader.get_data_field::<u16>(4) {
            0 => {
              return ::std::result::Result::Ok(None(
                ()
              ));
            }
            1 => {
              return ::std::result::Result::Ok(Aes(
                self.reader.get_pointer_field(1).get_data(::std::ptr::null(), 0)
              ));
            }
            x => return ::std::result::Result::Err(::capnp::NotInSchema(x))
          }
        }
      }

      pub struct Builder<'a> { builder : ::capnp::private::layout::StructBuilder<'a> }
      impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>
      {
        #[inline]
        fn struct_size() -> layout::StructSize { _private::STRUCT_SIZE }
      }
      impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>
       {
        #[inline]
        fn type_id() -> u64 { _private::TYPE_ID }
      }
      impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>
       {
        fn new(builder : ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
          Builder { builder : builder,  }
        }
      }

      impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>
       {
        fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
          self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
        }
      }

      impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>
       {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size : u32) -> Builder<'a,> {
          ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a,>> {
          ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
      }

      impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>
       {
        fn set_pointer_builder<'b>(pointer : ::capnp::private::layout::PointerBuilder<'b>, value : Reader<'a,>) -> Result<()> { pointer.set_struct(&value.reader) }
      }

      impl <'a,> Builder<'a,>
       {
        pub fn as_reader(self) -> Reader<'a,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b,> {
          Builder { .. *self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b,> {
          ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
          self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn set_none(&mut self, _value : ())  {
          self.builder.set_data_field::<u16>(4, 0);
        }
        #[inline]
        pub fn set_aes(&mut self, value : data::Reader)  {
          self.builder.set_data_field::<u16>(4, 1);
          self.builder.get_pointer_field(1).set_data(value);
        }
        #[inline]
        pub fn init_aes(self, size : u32) -> data::Builder<'a> {
          self.builder.set_data_field::<u16>(4, 1);
          self.builder.get_pointer_field(1).init_data(size)
        }
        pub fn has_aes(&self) -> bool {
          if self.builder.get_data_field::<u16>(4) != 1 { return false; }
          !self.builder.get_pointer_field(1).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichBuilder<'a,>, ::capnp::NotInSchema> {
          match self.builder.get_data_field::<u16>(4) {
            0 => {
              return ::std::result::Result::Ok(None(
                ()
              ));
            }
            1 => {
              return ::std::result::Result::Ok(Aes(
                self.builder.get_pointer_field(1).get_data(::std::ptr::null(), 0)
              ));
            }
            x => return ::std::result::Result::Err(::capnp::NotInSchema(x))
          }
        }
      }

      pub struct Pipeline { _typeless : ::capnp::any_pointer::Pipeline }
      impl FromTypelessPipeline for Pipeline {
        fn new(typeless : ::capnp::any_pointer::Pipeline) -> Pipeline {
          Pipeline { _typeless : typeless,  }
        }
      }
      impl Pipeline {
      }
      mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE : layout::StructSize = layout::StructSize { data : 2, pointers : 2 };
        pub const TYPE_ID: u64 = 0x842fdb3ba511bfb2;
      }
      pub enum Which<A0> {
        None(()),
        Aes(A0),
      }
      pub type WhichReader<'a,> = Which<Result<data::Reader<'a>>>;
      pub type WhichBuilder<'a,> = Which<Result<data::Builder<'a>>>;
    }
  }

  pub mod data_ref {
    #![allow(unused_imports)]
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::{text, data, Result};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};

    pub use self::Which::{Block,Indirect,Inline};

    pub struct Owned;
    impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> { reader : layout::StructReader<'a> }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>
    {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>
    {
      fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
        Reader { reader : reader,  }
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>
    {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>
    {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>
    {
      pub fn borrow<'b>(&'b self) -> Reader<'b,> {
        Reader { .. *self }
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      pub fn has_block(&self) -> bool {
        if self.reader.get_data_field::<u16>(0) != 0 { return false; }
        !self.reader.get_pointer_field(0).is_null()
      }
      pub fn has_indirect(&self) -> bool {
        if self.reader.get_data_field::<u16>(0) != 1 { return false; }
        !self.reader.get_pointer_field(0).is_null()
      }
      pub fn has_inline(&self) -> bool {
        if self.reader.get_data_field::<u16>(0) != 2 { return false; }
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn which(self) -> ::std::result::Result<WhichReader<'a,>, ::capnp::NotInSchema> {
        match self.reader.get_data_field::<u16>(0) {
          0 => {
            return ::std::result::Result::Ok(Block(
              ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))
            ));
          }
          1 => {
            return ::std::result::Result::Ok(Indirect(
              ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))
            ));
          }
          2 => {
            return ::std::result::Result::Ok(Inline(
              self.reader.get_pointer_field(0).get_data(::std::ptr::null(), 0)
            ));
          }
          x => return ::std::result::Result::Err(::capnp::NotInSchema(x))
        }
      }
    }

    pub struct Builder<'a> { builder : ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>
    {
      #[inline]
      fn struct_size() -> layout::StructSize { _private::STRUCT_SIZE }
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>
     {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>
     {
      fn new(builder : ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
        Builder { builder : builder,  }
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>
     {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>
     {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size : u32) -> Builder<'a,> {
        ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>
     {
      fn set_pointer_builder<'b>(pointer : ::capnp::private::layout::PointerBuilder<'b>, value : Reader<'a,>) -> Result<()> { pointer.set_struct(&value.reader) }
    }

    impl <'a,> Builder<'a,>
     {
      pub fn as_reader(self) -> Reader<'a,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }
      pub fn borrow<'b>(&'b mut self) -> Builder<'b,> {
        Builder { .. *self }
      }
      pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn set_block<'b>(&mut self, value : ::cafs_capnp::reference::block_ref::Reader<'b>) -> Result<()> {
        self.builder.set_data_field::<u16>(0, 0);
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
      }
      #[inline]
      pub fn init_block(self, ) -> ::cafs_capnp::reference::block_ref::Builder<'a> {
        self.builder.set_data_field::<u16>(0, 0);
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      pub fn has_block(&self) -> bool {
        if self.builder.get_data_field::<u16>(0) != 0 { return false; }
        !self.builder.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn set_indirect<'b>(&mut self, value : ::cafs_capnp::reference::block_ref::Reader<'b>) -> Result<()> {
        self.builder.set_data_field::<u16>(0, 1);
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
      }
      #[inline]
      pub fn init_indirect(self, ) -> ::cafs_capnp::reference::block_ref::Builder<'a> {
        self.builder.set_data_field::<u16>(0, 1);
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      pub fn has_indirect(&self) -> bool {
        if self.builder.get_data_field::<u16>(0) != 1 { return false; }
        !self.builder.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn set_inline(&mut self, value : data::Reader)  {
        self.builder.set_data_field::<u16>(0, 2);
        self.builder.get_pointer_field(0).set_data(value);
      }
      #[inline]
      pub fn init_inline(self, size : u32) -> data::Builder<'a> {
        self.builder.set_data_field::<u16>(0, 2);
        self.builder.get_pointer_field(0).init_data(size)
      }
      pub fn has_inline(&self) -> bool {
        if self.builder.get_data_field::<u16>(0) != 2 { return false; }
        !self.builder.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn which(self) -> ::std::result::Result<WhichBuilder<'a,>, ::capnp::NotInSchema> {
        match self.builder.get_data_field::<u16>(0) {
          0 => {
            return ::std::result::Result::Ok(Block(
              ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))
            ));
          }
          1 => {
            return ::std::result::Result::Ok(Indirect(
              ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))
            ));
          }
          2 => {
            return ::std::result::Result::Ok(Inline(
              self.builder.get_pointer_field(0).get_data(::std::ptr::null(), 0)
            ));
          }
          x => return ::std::result::Result::Err(::capnp::NotInSchema(x))
        }
      }
    }

    pub struct Pipeline { _typeless : ::capnp::any_pointer::Pipeline }
    impl FromTypelessPipeline for Pipeline {
      fn new(typeless : ::capnp::any_pointer::Pipeline) -> Pipeline {
        Pipeline { _typeless : typeless,  }
      }
    }
    impl Pipeline {
    }
    mod _private {
      use capnp::private::layout;
      pub const STRUCT_SIZE : layout::StructSize = layout::StructSize { data : 1, pointers : 1 };
      pub const TYPE_ID: u64 = 0xd275feca9dd4c6c1;
    }
    pub enum Which<A0,A1,A2> {
      Block(A0),
      Indirect(A1),
      Inline(A2),
    }
    pub type WhichReader<'a,> = Which<Result<::cafs_capnp::reference::block_ref::Reader<'a>>,Result<::cafs_capnp::reference::block_ref::Reader<'a>>,Result<data::Reader<'a>>>;
    pub type WhichBuilder<'a,> = Which<Result<::cafs_capnp::reference::block_ref::Builder<'a>>,Result<::cafs_capnp::reference::block_ref::Builder<'a>>,Result<data::Builder<'a>>>;
  }

  pub mod volume_ref {
    #![allow(unused_imports)]
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::{text, data, Result};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};

    pub struct Owned;
    impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> { reader : layout::StructReader<'a> }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>
    {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>
    {
      fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
        Reader { reader : reader,  }
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>
    {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>
    {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>
    {
      pub fn borrow<'b>(&'b self) -> Reader<'b,> {
        Reader { .. *self }
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_public_key(self) -> Result<data::Reader<'a>> {
        self.reader.get_pointer_field(0).get_data(::std::ptr::null(), 0)
      }
      pub fn has_public_key(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_volume_id(self) -> Result<data::Reader<'a>> {
        self.reader.get_pointer_field(1).get_data(::std::ptr::null(), 0)
      }
      pub fn has_volume_id(&self) -> bool {
        !self.reader.get_pointer_field(1).is_null()
      }
      #[inline]
      pub fn get_min_serial(self) -> i64 {
        self.reader.get_data_field::<i64>(0)
      }
    }

    pub struct Builder<'a> { builder : ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>
    {
      #[inline]
      fn struct_size() -> layout::StructSize { _private::STRUCT_SIZE }
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>
     {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>
     {
      fn new(builder : ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
        Builder { builder : builder,  }
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>
     {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>
     {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size : u32) -> Builder<'a,> {
        ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>
     {
      fn set_pointer_builder<'b>(pointer : ::capnp::private::layout::PointerBuilder<'b>, value : Reader<'a,>) -> Result<()> { pointer.set_struct(&value.reader) }
    }

    impl <'a,> Builder<'a,>
     {
      pub fn as_reader(self) -> Reader<'a,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }
      pub fn borrow<'b>(&'b mut self) -> Builder<'b,> {
        Builder { .. *self }
      }
      pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_public_key(self) -> Result<data::Builder<'a>> {
        self.builder.get_pointer_field(0).get_data(::std::ptr::null(), 0)
      }
      #[inline]
      pub fn set_public_key(&mut self, value : data::Reader)  {
        self.builder.get_pointer_field(0).set_data(value);
      }
      #[inline]
      pub fn init_public_key(self, size : u32) -> data::Builder<'a> {
        self.builder.get_pointer_field(0).init_data(size)
      }
      pub fn has_public_key(&self) -> bool {
        !self.builder.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_volume_id(self) -> Result<data::Builder<'a>> {
        self.builder.get_pointer_field(1).get_data(::std::ptr::null(), 0)
      }
      #[inline]
      pub fn set_volume_id(&mut self, value : data::Reader)  {
        self.builder.get_pointer_field(1).set_data(value);
      }
      #[inline]
      pub fn init_volume_id(self, size : u32) -> data::Builder<'a> {
        self.builder.get_pointer_field(1).init_data(size)
      }
      pub fn has_volume_id(&self) -> bool {
        !self.builder.get_pointer_field(1).is_null()
      }
      #[inline]
      pub fn get_min_serial(self) -> i64 {
        self.builder.get_data_field::<i64>(0)
      }
      #[inline]
      pub fn set_min_serial(&mut self, value : i64)  {
        self.builder.set_data_field::<i64>(0, value);
      }
    }

    pub struct Pipeline { _typeless : ::capnp::any_pointer::Pipeline }
    impl FromTypelessPipeline for Pipeline {
      fn new(typeless : ::capnp::any_pointer::Pipeline) -> Pipeline {
        Pipeline { _typeless : typeless,  }
      }
    }
    impl Pipeline {
    }
    mod _private {
      use capnp::private::layout;
      pub const STRUCT_SIZE : layout::StructSize = layout::StructSize { data : 1, pointers : 2 };
      pub const TYPE_ID: u64 = 0x82d67e453467b31d;
    }
  }
}

pub mod volume_root {
  #![allow(unused_imports)]
  use capnp::capability::{FromClientHook, FromTypelessPipeline};
  use capnp::{text, data, Result};
  use capnp::private::layout;
  use capnp::traits::{FromStructBuilder, FromStructReader};
  use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};

  pub struct Owned;
  impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
  impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

  #[derive(Clone, Copy)]
  pub struct Reader<'a> { reader : layout::StructReader<'a> }

  impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>
  {
    #[inline]
    fn type_id() -> u64 { _private::TYPE_ID }
  }
  impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>
  {
    fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
      Reader { reader : reader,  }
    }
  }

  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>
  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a,>> {
      ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
    }
  }

  impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>
  {
    fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
      self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
    }
  }

  impl <'a,> Reader<'a,>
  {
    pub fn borrow<'b>(&'b self) -> Reader<'b,> {
      Reader { .. *self }
    }

    pub fn total_size(&self) -> Result<::capnp::MessageSize> {
      self.reader.total_size()
    }
    #[inline]
    pub fn get_header(self) -> Result<data::Reader<'a>> {
      self.reader.get_pointer_field(0).get_data(::std::ptr::null(), 0)
    }
    pub fn has_header(&self) -> bool {
      !self.reader.get_pointer_field(0).is_null()
    }
    #[inline]
    pub fn get_signature(self) -> Result<data::Reader<'a>> {
      self.reader.get_pointer_field(1).get_data(::std::ptr::null(), 0)
    }
    pub fn has_signature(&self) -> bool {
      !self.reader.get_pointer_field(1).is_null()
    }
  }

  pub struct Builder<'a> { builder : ::capnp::private::layout::StructBuilder<'a> }
  impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>
  {
    #[inline]
    fn struct_size() -> layout::StructSize { _private::STRUCT_SIZE }
  }
  impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>
   {
    #[inline]
    fn type_id() -> u64 { _private::TYPE_ID }
  }
  impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>
   {
    fn new(builder : ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
      Builder { builder : builder,  }
    }
  }

  impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>
   {
    fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
      self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
    }
  }

  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>
   {
    fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size : u32) -> Builder<'a,> {
      ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a,>> {
      ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
    }
  }

  impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>
   {
    fn set_pointer_builder<'b>(pointer : ::capnp::private::layout::PointerBuilder<'b>, value : Reader<'a,>) -> Result<()> { pointer.set_struct(&value.reader) }
  }

  impl <'a,> Builder<'a,>
   {
    pub fn as_reader(self) -> Reader<'a,> {
      ::capnp::traits::FromStructReader::new(self.builder.as_reader())
    }
    pub fn borrow<'b>(&'b mut self) -> Builder<'b,> {
      Builder { .. *self }
    }
    pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b,> {
      ::capnp::traits::FromStructReader::new(self.builder.as_reader())
    }

    pub fn total_size(&self) -> Result<::capnp::MessageSize> {
      self.builder.as_reader().total_size()
    }
    #[inline]
    pub fn get_header(self) -> Result<data::Builder<'a>> {
      self.builder.get_pointer_field(0).get_data(::std::ptr::null(), 0)
    }
    #[inline]
    pub fn set_header(&mut self, value : data::Reader)  {
      self.builder.get_pointer_field(0).set_data(value);
    }
    #[inline]
    pub fn init_header(self, size : u32) -> data::Builder<'a> {
      self.builder.get_pointer_field(0).init_data(size)
    }
    pub fn has_header(&self) -> bool {
      !self.builder.get_pointer_field(0).is_null()
    }
    #[inline]
    pub fn get_signature(self) -> Result<data::Builder<'a>> {
      self.builder.get_pointer_field(1).get_data(::std::ptr::null(), 0)
    }
    #[inline]
    pub fn set_signature(&mut self, value : data::Reader)  {
      self.builder.get_pointer_field(1).set_data(value);
    }
    #[inline]
    pub fn init_signature(self, size : u32) -> data::Builder<'a> {
      self.builder.get_pointer_field(1).init_data(size)
    }
    pub fn has_signature(&self) -> bool {
      !self.builder.get_pointer_field(1).is_null()
    }
  }

  pub struct Pipeline { _typeless : ::capnp::any_pointer::Pipeline }
  impl FromTypelessPipeline for Pipeline {
    fn new(typeless : ::capnp::any_pointer::Pipeline) -> Pipeline {
      Pipeline { _typeless : typeless,  }
    }
  }
  impl Pipeline {
  }
  mod _private {
    use capnp::private::layout;
    pub const STRUCT_SIZE : layout::StructSize = layout::StructSize { data : 0, pointers : 2 };
    pub const TYPE_ID: u64 = 0xcf057af49c056990;
  }
}

pub mod volume_header {
  #![allow(unused_imports)]
  use capnp::capability::{FromClientHook, FromTypelessPipeline};
  use capnp::{text, data, Result};
  use capnp::private::layout;
  use capnp::traits::{FromStructBuilder, FromStructReader};
  use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};

  pub struct Owned;
  impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
  impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

  #[derive(Clone, Copy)]
  pub struct Reader<'a> { reader : layout::StructReader<'a> }

  impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>
  {
    #[inline]
    fn type_id() -> u64 { _private::TYPE_ID }
  }
  impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>
  {
    fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
      Reader { reader : reader,  }
    }
  }

  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>
  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a,>> {
      ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
    }
  }

  impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>
  {
    fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
      self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
    }
  }

  impl <'a,> Reader<'a,>
  {
    pub fn borrow<'b>(&'b self) -> Reader<'b,> {
      Reader { .. *self }
    }

    pub fn total_size(&self) -> Result<::capnp::MessageSize> {
      self.reader.total_size()
    }
    #[inline]
    pub fn get_volume_id(self) -> Result<data::Reader<'a>> {
      self.reader.get_pointer_field(0).get_data(::std::ptr::null(), 0)
    }
    pub fn has_volume_id(&self) -> bool {
      !self.reader.get_pointer_field(0).is_null()
    }
    #[inline]
    pub fn get_serial(self) -> i64 {
      self.reader.get_data_field::<i64>(0)
    }
    #[inline]
    pub fn get_contents(self) -> ::cafs_capnp::volume_header::contents::Reader<'a> {
      ::capnp::traits::FromStructReader::new(self.reader)
    }
  }

  pub struct Builder<'a> { builder : ::capnp::private::layout::StructBuilder<'a> }
  impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>
  {
    #[inline]
    fn struct_size() -> layout::StructSize { _private::STRUCT_SIZE }
  }
  impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>
   {
    #[inline]
    fn type_id() -> u64 { _private::TYPE_ID }
  }
  impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>
   {
    fn new(builder : ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
      Builder { builder : builder,  }
    }
  }

  impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>
   {
    fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
      self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
    }
  }

  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>
   {
    fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size : u32) -> Builder<'a,> {
      ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a,>> {
      ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
    }
  }

  impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>
   {
    fn set_pointer_builder<'b>(pointer : ::capnp::private::layout::PointerBuilder<'b>, value : Reader<'a,>) -> Result<()> { pointer.set_struct(&value.reader) }
  }

  impl <'a,> Builder<'a,>
   {
    pub fn as_reader(self) -> Reader<'a,> {
      ::capnp::traits::FromStructReader::new(self.builder.as_reader())
    }
    pub fn borrow<'b>(&'b mut self) -> Builder<'b,> {
      Builder { .. *self }
    }
    pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b,> {
      ::capnp::traits::FromStructReader::new(self.builder.as_reader())
    }

    pub fn total_size(&self) -> Result<::capnp::MessageSize> {
      self.builder.as_reader().total_size()
    }
    #[inline]
    pub fn get_volume_id(self) -> Result<data::Builder<'a>> {
      self.builder.get_pointer_field(0).get_data(::std::ptr::null(), 0)
    }
    #[inline]
    pub fn set_volume_id(&mut self, value : data::Reader)  {
      self.builder.get_pointer_field(0).set_data(value);
    }
    #[inline]
    pub fn init_volume_id(self, size : u32) -> data::Builder<'a> {
      self.builder.get_pointer_field(0).init_data(size)
    }
    pub fn has_volume_id(&self) -> bool {
      !self.builder.get_pointer_field(0).is_null()
    }
    #[inline]
    pub fn get_serial(self) -> i64 {
      self.builder.get_data_field::<i64>(0)
    }
    #[inline]
    pub fn set_serial(&mut self, value : i64)  {
      self.builder.set_data_field::<i64>(0, value);
    }
    #[inline]
    pub fn get_contents(self) -> ::cafs_capnp::volume_header::contents::Builder<'a> {
      ::capnp::traits::FromStructBuilder::new(self.builder)
    }
    #[inline]
    pub fn init_contents(self, ) -> ::cafs_capnp::volume_header::contents::Builder<'a> {
      self.builder.set_data_field::<u16>(4, 0);
      self.builder.get_pointer_field(1).clear();
      ::capnp::traits::FromStructBuilder::new(self.builder)
    }
  }

  pub struct Pipeline { _typeless : ::capnp::any_pointer::Pipeline }
  impl FromTypelessPipeline for Pipeline {
    fn new(typeless : ::capnp::any_pointer::Pipeline) -> Pipeline {
      Pipeline { _typeless : typeless,  }
    }
  }
  impl Pipeline {
    pub fn get_contents(&self) -> ::cafs_capnp::volume_header::contents::Pipeline {
      FromTypelessPipeline::new(self._typeless.noop())
    }
  }
  mod _private {
    use capnp::private::layout;
    pub const STRUCT_SIZE : layout::StructSize = layout::StructSize { data : 2, pointers : 2 };
    pub const TYPE_ID: u64 = 0x8ea2986d4955b255;
  }

  pub mod private_ref {
    #![allow(unused_imports)]
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::{text, data, Result};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};

    pub struct Owned;
    impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> { reader : layout::StructReader<'a> }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>
    {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>
    {
      fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
        Reader { reader : reader,  }
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>
    {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>
    {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>
    {
      pub fn borrow<'b>(&'b self) -> Reader<'b,> {
        Reader { .. *self }
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_ref(self) -> Result<data::Reader<'a>> {
        self.reader.get_pointer_field(0).get_data(::std::ptr::null(), 0)
      }
      pub fn has_ref(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_keys(self) -> Result<data_list::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(1))
      }
      pub fn has_keys(&self) -> bool {
        !self.reader.get_pointer_field(1).is_null()
      }
    }

    pub struct Builder<'a> { builder : ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>
    {
      #[inline]
      fn struct_size() -> layout::StructSize { _private::STRUCT_SIZE }
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>
     {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>
     {
      fn new(builder : ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
        Builder { builder : builder,  }
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>
     {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>
     {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size : u32) -> Builder<'a,> {
        ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>
     {
      fn set_pointer_builder<'b>(pointer : ::capnp::private::layout::PointerBuilder<'b>, value : Reader<'a,>) -> Result<()> { pointer.set_struct(&value.reader) }
    }

    impl <'a,> Builder<'a,>
     {
      pub fn as_reader(self) -> Reader<'a,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }
      pub fn borrow<'b>(&'b mut self) -> Builder<'b,> {
        Builder { .. *self }
      }
      pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_ref(self) -> Result<data::Builder<'a>> {
        self.builder.get_pointer_field(0).get_data(::std::ptr::null(), 0)
      }
      #[inline]
      pub fn set_ref(&mut self, value : data::Reader)  {
        self.builder.get_pointer_field(0).set_data(value);
      }
      #[inline]
      pub fn init_ref(self, size : u32) -> data::Builder<'a> {
        self.builder.get_pointer_field(0).init_data(size)
      }
      pub fn has_ref(&self) -> bool {
        !self.builder.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_keys(self) -> Result<data_list::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(1))
      }
      #[inline]
      pub fn set_keys(&mut self, value : data_list::Reader<'a>) -> Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(1), value)
      }
      #[inline]
      pub fn init_keys(self, size : u32) -> data_list::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(1), size)
      }
      pub fn has_keys(&self) -> bool {
        !self.builder.get_pointer_field(1).is_null()
      }
    }

    pub struct Pipeline { _typeless : ::capnp::any_pointer::Pipeline }
    impl FromTypelessPipeline for Pipeline {
      fn new(typeless : ::capnp::any_pointer::Pipeline) -> Pipeline {
        Pipeline { _typeless : typeless,  }
      }
    }
    impl Pipeline {
    }
    mod _private {
      use capnp::private::layout;
      pub const STRUCT_SIZE : layout::StructSize = layout::StructSize { data : 0, pointers : 2 };
      pub const TYPE_ID: u64 = 0x9ab140fbdcf1a0e2;
    }
  }

  pub mod contents {
    #![allow(unused_imports)]
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::{text, data, Result};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};

    pub use self::Which::{Public,Private};

    pub struct Owned;
    impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> { reader : layout::StructReader<'a> }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>
    {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>
    {
      fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
        Reader { reader : reader,  }
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>
    {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>
    {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>
    {
      pub fn borrow<'b>(&'b self) -> Reader<'b,> {
        Reader { .. *self }
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      pub fn has_public(&self) -> bool {
        if self.reader.get_data_field::<u16>(4) != 0 { return false; }
        !self.reader.get_pointer_field(1).is_null()
      }
      pub fn has_private(&self) -> bool {
        if self.reader.get_data_field::<u16>(4) != 1 { return false; }
        !self.reader.get_pointer_field(1).is_null()
      }
      #[inline]
      pub fn which(self) -> ::std::result::Result<WhichReader<'a,>, ::capnp::NotInSchema> {
        match self.reader.get_data_field::<u16>(4) {
          0 => {
            return ::std::result::Result::Ok(Public(
              ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(1))
            ));
          }
          1 => {
            return ::std::result::Result::Ok(Private(
              ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(1))
            ));
          }
          x => return ::std::result::Result::Err(::capnp::NotInSchema(x))
        }
      }
    }

    pub struct Builder<'a> { builder : ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>
    {
      #[inline]
      fn struct_size() -> layout::StructSize { _private::STRUCT_SIZE }
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>
     {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>
     {
      fn new(builder : ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
        Builder { builder : builder,  }
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>
     {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>
     {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size : u32) -> Builder<'a,> {
        ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>
     {
      fn set_pointer_builder<'b>(pointer : ::capnp::private::layout::PointerBuilder<'b>, value : Reader<'a,>) -> Result<()> { pointer.set_struct(&value.reader) }
    }

    impl <'a,> Builder<'a,>
     {
      pub fn as_reader(self) -> Reader<'a,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }
      pub fn borrow<'b>(&'b mut self) -> Builder<'b,> {
        Builder { .. *self }
      }
      pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn set_public<'b>(&mut self, value : ::cafs_capnp::reference::Reader<'b>) -> Result<()> {
        self.builder.set_data_field::<u16>(4, 0);
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(1), value)
      }
      #[inline]
      pub fn init_public(self, ) -> ::cafs_capnp::reference::Builder<'a> {
        self.builder.set_data_field::<u16>(4, 0);
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(1), 0)
      }
      pub fn has_public(&self) -> bool {
        if self.builder.get_data_field::<u16>(4) != 0 { return false; }
        !self.builder.get_pointer_field(1).is_null()
      }
      #[inline]
      pub fn set_private<'b>(&mut self, value : ::cafs_capnp::volume_header::private_ref::Reader<'b>) -> Result<()> {
        self.builder.set_data_field::<u16>(4, 1);
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(1), value)
      }
      #[inline]
      pub fn init_private(self, ) -> ::cafs_capnp::volume_header::private_ref::Builder<'a> {
        self.builder.set_data_field::<u16>(4, 1);
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(1), 0)
      }
      pub fn has_private(&self) -> bool {
        if self.builder.get_data_field::<u16>(4) != 1 { return false; }
        !self.builder.get_pointer_field(1).is_null()
      }
      #[inline]
      pub fn which(self) -> ::std::result::Result<WhichBuilder<'a,>, ::capnp::NotInSchema> {
        match self.builder.get_data_field::<u16>(4) {
          0 => {
            return ::std::result::Result::Ok(Public(
              ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(1))
            ));
          }
          1 => {
            return ::std::result::Result::Ok(Private(
              ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(1))
            ));
          }
          x => return ::std::result::Result::Err(::capnp::NotInSchema(x))
        }
      }
    }

    pub struct Pipeline { _typeless : ::capnp::any_pointer::Pipeline }
    impl FromTypelessPipeline for Pipeline {
      fn new(typeless : ::capnp::any_pointer::Pipeline) -> Pipeline {
        Pipeline { _typeless : typeless,  }
      }
    }
    impl Pipeline {
    }
    mod _private {
      use capnp::private::layout;
      pub const STRUCT_SIZE : layout::StructSize = layout::StructSize { data : 2, pointers : 2 };
      pub const TYPE_ID: u64 = 0xc8327e412fbf364f;
    }
    pub enum Which<A0,A1> {
      Public(A0),
      Private(A1),
    }
    pub type WhichReader<'a,> = Which<Result<::cafs_capnp::reference::Reader<'a>>,Result<::cafs_capnp::volume_header::private_ref::Reader<'a>>>;
    pub type WhichBuilder<'a,> = Which<Result<::cafs_capnp::reference::Builder<'a>>,Result<::cafs_capnp::volume_header::private_ref::Builder<'a>>>;
  }
}

pub mod indirect_block {
  #![allow(unused_imports)]
  use capnp::capability::{FromClientHook, FromTypelessPipeline};
  use capnp::{text, data, Result};
  use capnp::private::layout;
  use capnp::traits::{FromStructBuilder, FromStructReader};
  use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};

  pub struct Owned;
  impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
  impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

  #[derive(Clone, Copy)]
  pub struct Reader<'a> { reader : layout::StructReader<'a> }

  impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>
  {
    #[inline]
    fn type_id() -> u64 { _private::TYPE_ID }
  }
  impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>
  {
    fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
      Reader { reader : reader,  }
    }
  }

  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>
  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a,>> {
      ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
    }
  }

  impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>
  {
    fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
      self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
    }
  }

  impl <'a,> Reader<'a,>
  {
    pub fn borrow<'b>(&'b self) -> Reader<'b,> {
      Reader { .. *self }
    }

    pub fn total_size(&self) -> Result<::capnp::MessageSize> {
      self.reader.total_size()
    }
    #[inline]
    pub fn get_subblocks(self) -> Result<struct_list::Reader<'a,::cafs_capnp::reference::data_ref::Owned<>>> {
      ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))
    }
    pub fn has_subblocks(&self) -> bool {
      !self.reader.get_pointer_field(0).is_null()
    }
  }

  pub struct Builder<'a> { builder : ::capnp::private::layout::StructBuilder<'a> }
  impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>
  {
    #[inline]
    fn struct_size() -> layout::StructSize { _private::STRUCT_SIZE }
  }
  impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>
   {
    #[inline]
    fn type_id() -> u64 { _private::TYPE_ID }
  }
  impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>
   {
    fn new(builder : ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
      Builder { builder : builder,  }
    }
  }

  impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>
   {
    fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
      self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
    }
  }

  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>
   {
    fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size : u32) -> Builder<'a,> {
      ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a,>> {
      ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
    }
  }

  impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>
   {
    fn set_pointer_builder<'b>(pointer : ::capnp::private::layout::PointerBuilder<'b>, value : Reader<'a,>) -> Result<()> { pointer.set_struct(&value.reader) }
  }

  impl <'a,> Builder<'a,>
   {
    pub fn as_reader(self) -> Reader<'a,> {
      ::capnp::traits::FromStructReader::new(self.builder.as_reader())
    }
    pub fn borrow<'b>(&'b mut self) -> Builder<'b,> {
      Builder { .. *self }
    }
    pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b,> {
      ::capnp::traits::FromStructReader::new(self.builder.as_reader())
    }

    pub fn total_size(&self) -> Result<::capnp::MessageSize> {
      self.builder.as_reader().total_size()
    }
    #[inline]
    pub fn get_subblocks(self) -> Result<struct_list::Builder<'a,::cafs_capnp::reference::data_ref::Owned<>>> {
      ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))
    }
    #[inline]
    pub fn set_subblocks(&mut self, value : struct_list::Reader<'a,::cafs_capnp::reference::data_ref::Owned<>>) -> Result<()> {
      ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
    }
    #[inline]
    pub fn init_subblocks(self, size : u32) -> struct_list::Builder<'a,::cafs_capnp::reference::data_ref::Owned<>> {
      ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), size)
    }
    pub fn has_subblocks(&self) -> bool {
      !self.builder.get_pointer_field(0).is_null()
    }
  }

  pub struct Pipeline { _typeless : ::capnp::any_pointer::Pipeline }
  impl FromTypelessPipeline for Pipeline {
    fn new(typeless : ::capnp::any_pointer::Pipeline) -> Pipeline {
      Pipeline { _typeless : typeless,  }
    }
  }
  impl Pipeline {
  }
  mod _private {
    use capnp::private::layout;
    pub const STRUCT_SIZE : layout::StructSize = layout::StructSize { data : 0, pointers : 1 };
    pub const TYPE_ID: u64 = 0xe5368b03970d1ab1;
  }
}

pub mod directory {
  #![allow(unused_imports)]
  use capnp::capability::{FromClientHook, FromTypelessPipeline};
  use capnp::{text, data, Result};
  use capnp::private::layout;
  use capnp::traits::{FromStructBuilder, FromStructReader};
  use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};

  pub struct Owned;
  impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
  impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

  #[derive(Clone, Copy)]
  pub struct Reader<'a> { reader : layout::StructReader<'a> }

  impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>
  {
    #[inline]
    fn type_id() -> u64 { _private::TYPE_ID }
  }
  impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>
  {
    fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
      Reader { reader : reader,  }
    }
  }

  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>
  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a,>> {
      ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
    }
  }

  impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>
  {
    fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
      self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
    }
  }

  impl <'a,> Reader<'a,>
  {
    pub fn borrow<'b>(&'b self) -> Reader<'b,> {
      Reader { .. *self }
    }

    pub fn total_size(&self) -> Result<::capnp::MessageSize> {
      self.reader.total_size()
    }
    #[inline]
    pub fn get_files(self) -> Result<struct_list::Reader<'a,::cafs_capnp::directory::entry::Owned<>>> {
      ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))
    }
    pub fn has_files(&self) -> bool {
      !self.reader.get_pointer_field(0).is_null()
    }
  }

  pub struct Builder<'a> { builder : ::capnp::private::layout::StructBuilder<'a> }
  impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>
  {
    #[inline]
    fn struct_size() -> layout::StructSize { _private::STRUCT_SIZE }
  }
  impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>
   {
    #[inline]
    fn type_id() -> u64 { _private::TYPE_ID }
  }
  impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>
   {
    fn new(builder : ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
      Builder { builder : builder,  }
    }
  }

  impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>
   {
    fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
      self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
    }
  }

  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>
   {
    fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size : u32) -> Builder<'a,> {
      ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a,>> {
      ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
    }
  }

  impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>
   {
    fn set_pointer_builder<'b>(pointer : ::capnp::private::layout::PointerBuilder<'b>, value : Reader<'a,>) -> Result<()> { pointer.set_struct(&value.reader) }
  }

  impl <'a,> Builder<'a,>
   {
    pub fn as_reader(self) -> Reader<'a,> {
      ::capnp::traits::FromStructReader::new(self.builder.as_reader())
    }
    pub fn borrow<'b>(&'b mut self) -> Builder<'b,> {
      Builder { .. *self }
    }
    pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b,> {
      ::capnp::traits::FromStructReader::new(self.builder.as_reader())
    }

    pub fn total_size(&self) -> Result<::capnp::MessageSize> {
      self.builder.as_reader().total_size()
    }
    #[inline]
    pub fn get_files(self) -> Result<struct_list::Builder<'a,::cafs_capnp::directory::entry::Owned<>>> {
      ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))
    }
    #[inline]
    pub fn set_files(&mut self, value : struct_list::Reader<'a,::cafs_capnp::directory::entry::Owned<>>) -> Result<()> {
      ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
    }
    #[inline]
    pub fn init_files(self, size : u32) -> struct_list::Builder<'a,::cafs_capnp::directory::entry::Owned<>> {
      ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), size)
    }
    pub fn has_files(&self) -> bool {
      !self.builder.get_pointer_field(0).is_null()
    }
  }

  pub struct Pipeline { _typeless : ::capnp::any_pointer::Pipeline }
  impl FromTypelessPipeline for Pipeline {
    fn new(typeless : ::capnp::any_pointer::Pipeline) -> Pipeline {
      Pipeline { _typeless : typeless,  }
    }
  }
  impl Pipeline {
  }
  mod _private {
    use capnp::private::layout;
    pub const STRUCT_SIZE : layout::StructSize = layout::StructSize { data : 0, pointers : 1 };
    pub const TYPE_ID: u64 = 0xc4f26d6cef3a81e0;
  }

  pub mod entry {
    #![allow(unused_imports)]
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::{text, data, Result};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};

    pub struct Owned;
    impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl <'a> ::capnp::traits::OwnedStruct<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> { reader : layout::StructReader<'a> }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>
    {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructReader<'a> for Reader<'a,>
    {
      fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a,> {
        Reader { reader : reader,  }
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>
    {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>
    {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>
    {
      pub fn borrow<'b>(&'b self) -> Reader<'b,> {
        Reader { .. *self }
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_name(self) -> Result<text::Reader<'a>> {
        self.reader.get_pointer_field(0).get_text(::std::ptr::null(), 0)
      }
      pub fn has_name(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_ref(self) -> Result<::cafs_capnp::reference::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(1))
      }
      pub fn has_ref(&self) -> bool {
        !self.reader.get_pointer_field(1).is_null()
      }
    }

    pub struct Builder<'a> { builder : ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>
    {
      #[inline]
      fn struct_size() -> layout::StructSize { _private::STRUCT_SIZE }
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>
     {
      #[inline]
      fn type_id() -> u64 { _private::TYPE_ID }
    }
    impl <'a,> ::capnp::traits::FromStructBuilder<'a> for Builder<'a,>
     {
      fn new(builder : ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a, > {
        Builder { builder : builder,  }
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>
     {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>
     {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size : u32) -> Builder<'a,> {
        ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a,>> {
        ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder<Builder<'a,>> for Reader<'a,>
     {
      fn set_pointer_builder<'b>(pointer : ::capnp::private::layout::PointerBuilder<'b>, value : Reader<'a,>) -> Result<()> { pointer.set_struct(&value.reader) }
    }

    impl <'a,> Builder<'a,>
     {
      pub fn as_reader(self) -> Reader<'a,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }
      pub fn borrow<'b>(&'b mut self) -> Builder<'b,> {
        Builder { .. *self }
      }
      pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b,> {
        ::capnp::traits::FromStructReader::new(self.builder.as_reader())
      }

      pub fn total_size(&self) -> Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_name(self) -> Result<text::Builder<'a>> {
        self.builder.get_pointer_field(0).get_text(::std::ptr::null(), 0)
      }
      #[inline]
      pub fn set_name(&mut self, value : text::Reader)  {
        self.builder.get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_name(self, size : u32) -> text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      pub fn has_name(&self) -> bool {
        !self.builder.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_ref(self) -> Result<::cafs_capnp::reference::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(1))
      }
      #[inline]
      pub fn set_ref<'b>(&mut self, value : ::cafs_capnp::reference::Reader<'b>) -> Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(1), value)
      }
      #[inline]
      pub fn init_ref(self, ) -> ::cafs_capnp::reference::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(1), 0)
      }
      pub fn has_ref(&self) -> bool {
        !self.builder.get_pointer_field(1).is_null()
      }
    }

    pub struct Pipeline { _typeless : ::capnp::any_pointer::Pipeline }
    impl FromTypelessPipeline for Pipeline {
      fn new(typeless : ::capnp::any_pointer::Pipeline) -> Pipeline {
        Pipeline { _typeless : typeless,  }
      }
    }
    impl Pipeline {
      pub fn get_ref(&self) -> ::cafs_capnp::reference::Pipeline<> {
        FromTypelessPipeline::new(self._typeless.get_pointer_field(1))
      }
    }
    mod _private {
      use capnp::private::layout;
      pub const STRUCT_SIZE : layout::StructSize = layout::StructSize { data : 0, pointers : 2 };
      pub const TYPE_ID: u64 = 0xb69e2f1aa5a20d68;
    }
  }
}
